# -*- coding: utf-8 -*-
"""file.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RLXPe-EBPm9z07sPABCtvOYeZU-VKoxl
"""

!pip install nashpy
!pip install memory_profiler

import numpy as np
import time
from nashpy import Game

def benchmark_algorithm(algorithm, game):
    """
    Measure the time taken by a Nash equilibrium finding algorithm to compute equilibria for a given game.

    Parameters:
    - algorithm (callable): The Nash equilibrium algorithm to be benchmarked.
    - game (nashpy.Game): The game instance on which the algorithm is applied.

    Returns:
    - list: A list of calculated Nash equilibria.
    - float: The time taken to compute the equilibria, in seconds.
    """
    start_time = time.time()
    equilibria = list(algorithm())
    end_time = time.time()
    return equilibria, end_time - start_time

def generate_payoff_matrix(size):
    """
    Generates a random payoff matrix of a specified size for a game.

    Parameters:
    - size (int): The size of the payoff matrix to generate.

    Returns:
    - numpy.ndarray: A square matrix of shape (size, size) filled with random values.
    """
    return np.random.rand(size, size)

def benchmark_game_sizes(max_size):
    """
    Benchmarks the performance of support and vertex enumeration methods for Nash equilibrium computation across various game sizes.

    Parameters:
    - max_size (int): The maximum size of the game matrix to be benchmarked.

    Returns:
    - list: Time taken by support enumeration for each size, in seconds.
    - list: Time taken by vertex enumeration for each size, in seconds.
    """
    support_enumeration_times = []
    vertex_enumeration_times = []

    for size in range(2, max_size + 1):
        A = generate_payoff_matrix(size)
        B = generate_payoff_matrix(size)

        game = Game(A, B)

        se_equilibria, se_time = benchmark_algorithm(game.support_enumeration, game)
        support_enumeration_times.append(se_time)

        ve_equilibria, ve_time = benchmark_algorithm(game.vertex_enumeration, game)
        vertex_enumeration_times.append(ve_time)

        print(f"Size: {size}")
        print(f"Support Enumeration - Time: {se_time}")
        print(f"Vertex Enumeration - Time: {ve_time}")

    return support_enumeration_times, vertex_enumeration_times

# Running the benchmark and storing the results
support_enumeration_times, vertex_enumeration_times = benchmark_game_sizes(7)

import matplotlib.pyplot as plt

sizes = list(range(2, 8))  # Sizes from 2 to 8

# Plotting the results
plt.figure(figsize=(12, 6))
plt.plot(sizes, support_enumeration_times, marker='o', label='Support Enumeration')
plt.plot(sizes, vertex_enumeration_times, marker='s', label='Vertex Enumeration')
plt.xlabel('Size of Game (NxN)')
plt.ylabel('Time taken (seconds)')
plt.title('Run Time of Nash Equilibrium Algorithms')
plt.legend()
plt.yscale('log')  # Using a logarithmic scale for better visibility
plt.xticks(sizes)
plt.grid(True)
plt.show()

from memory_profiler import memory_usage
import numpy as np
from nashpy import Game

np.random.seed(5)

def generate_payoff_matrix(size):
    """
    Generates a random payoff matrix of a specified size for a game.

    Parameters:
    - size (int): The size of the payoff matrix to generate.

    Returns:
    - numpy.ndarray: A square matrix of shape (size, size) filled with random values.
    """
    return np.random.rand(size, size)

def profile_memory(algorithm, *args):
    """
    Profiles the peak memory usage of a given algorithm.

    Parameters:
    - algorithm (callable): The algorithm to profile.
    - *args: Arguments to be passed to the algorithm.

    Returns:
    - float: The peak memory usage in MiB.
    """
    mem_usage = memory_usage((algorithm, args), interval=0.01, timeout=120)
    return max(mem_usage)

def run_memory_profiling(max_size):
    """
    Runs memory profiling for support and vertex enumeration methods across different game sizes.

    Parameters:
    - max_size (int): The maximum size of the game matrix to be profiled.

    Returns:
    - list: The sizes of the game matrices.
    - list: Memory usages of support enumeration for each size, in MiB.
    - list: Memory usages of vertex enumeration for each size, in MiB.
    """
    se_memory_usages = []
    ve_memory_usages = []
    sizes = range(2, max_size + 1)

    for size in sizes:
        A = generate_payoff_matrix(size)
        B = generate_payoff_matrix(size)
        game = Game(A, B)

        se_mem_usage = profile_memory(game.support_enumeration)
        se_memory_usages.append(se_mem_usage)

        ve_mem_usage = profile_memory(lambda: list(game.vertex_enumeration()))
        ve_memory_usages.append(ve_mem_usage)

    return sizes, se_memory_usages, ve_memory_usages

# Defining the maximum size for the memory profiling
max_game_size = 7
sizes, se_memory_usages, ve_memory_usages = run_memory_profiling(max_game_size)

# Printing the results
for size, se_mem, ve_mem in zip(sizes, se_memory_usages, ve_memory_usages):
    print(f"Size: {size}x{size}")
    print(f"Support Enumeration Memory Usage: {se_mem} MiB")
    print(f"Vertex Enumeration Memory Usage: {ve_mem} MiB")

import matplotlib.pyplot as plt

# Plotting the results
plt.figure(figsize=(12, 6))
plt.plot(sizes, se_memory_usages, marker='o', label='Support Enumeration Memory Usage')
plt.plot(sizes, ve_memory_usages, marker='s', label='Vertex Enumeration Memory Usage')
plt.xlabel('Size of Game (NxN)')
plt.ylabel('Memory Usage (MiB)')
plt.title('Memory Usage of Nash Equilibrium Algorithms')
plt.legend()
plt.xticks(sizes)
plt.grid(True)
plt.show()

import numpy as np
from nashpy import Game

np.random.seed(5)

def generate_random_game(size):
    """
    Generates a random game instance by creating random payoff matrices for two players.

    Parameters:
    - size (int): The size of the square payoff matrices to generate for each player.

    Returns:
    - nashpy.Game: A game instance with the generated random payoff matrices for two players.
    """
    A = np.random.rand(size, size)
    B = np.random.rand(size, size)
    return Game(A, B)

def count_equilibria(game, algorithm):
    """
    Counts the number of Nash equilibria found by a given algorithm for a specified game.

    Parameters:
    - game (nashpy.Game): The game for which Nash equilibria are to be counted.
    - algorithm (callable): The Nash equilibrium finding algorithm.

    Returns:
    - int: The number of Nash equilibria found by the algorithm.
    """
    return len(list(algorithm()))

# Initializing lists to store the results
equilibria_counts_se = []
equilibria_counts_ve = []

# Define the range of game sizes to analyze
max_size = 7

# Analyzing the number of equilibria for increasing game sizes
for size in range(2, max_size + 1):
    game = generate_random_game(size)

    count_se = count_equilibria(game, game.support_enumeration)
    count_ve = count_equilibria(game, game.vertex_enumeration)

    equilibria_counts_se.append((size, count_se))
    equilibria_counts_ve.append((size, count_ve))

# Printing results for Support Enumeration
print("Support Enumeration Equilibria Counts:")
for size, count in equilibria_counts_se:
    print(f"Game Size: {size}x{size}, Equilibria Count: {count}")

# Printing results for Vertex Enumeration
print("\nVertex Enumeration Equilibria Counts:")
for size, count in equilibria_counts_ve:
    print(f"Game Size: {size}x{size}, Equilibria Count: {count}")

import matplotlib.pyplot as plt


# Extracting sizes and counts for plotting
sizes_se, counts_se = zip(*equilibria_counts_se)
sizes_ve, counts_ve = zip(*equilibria_counts_ve)

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(sizes_se, counts_se, marker='o', label='Support Enumeration')
plt.plot(sizes_ve, counts_ve, marker='s', label='Vertex Enumeration')
plt.xlabel('Game Size (NxN)')
plt.ylabel('Number of Equilibria')
plt.title('Number of Nash Equilibria Found by Different Algorithms for Various Game Sizes')
plt.legend()
plt.xticks(range(2, max(sizes_se) + 1))
plt.grid(True)
plt.show()

